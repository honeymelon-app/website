name: Release Build

on:
  release:
    types: [published]

permissions:
  contents: write

env:
  NODE_VERSION: '20'
  RUST_TARGET: aarch64-apple-darwin

jobs:
  pre-release-checks:
    name: Pre-Release Validation
    runs-on: macos-14
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy
          targets: ${{ env.RUST_TARGET }}
      - uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri
      - run: npm ci
      - name: Refresh FFmpeg sidecars
        run: npm run download-ffmpeg
      - run: npm run build --if-present
      - run: npm run lint:js || true
      - run: npm run format:check:js || true
      - run: cd src-tauri && cargo fmt --all -- --check
      - run: cd src-tauri && cargo clippy --all-targets --all-features -- -D warnings
      - run: cd src-tauri && cargo test --all-features --lib
      - run: |
          if grep -q '"vitest"' package.json || [ -f "vitest.config.ts" ] || [ -f "vitest.config.js" ]; then
            npm run test:unit
          else
            echo "No tests configured"
          fi

  build-and-upload:
    name: Build and Upload Artifacts
    runs-on: macos-14
    needs: pre-release-checks
    env:
      HAS_DEV_ID: ${{ secrets.APPLE_SIGNING_IDENTITY != '' }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ env.RUST_TARGET }}
      - uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri
      - run: npm ci

      - name: Setup FFmpeg binaries
        run: |
          npm run download-ffmpeg
          ls -lh src-tauri/bin/
          file src-tauri/bin/ffmpeg src-tauri/bin/ffprobe
          src-tauri/bin/ffmpeg -version | head -1 || true

      - name: Sign FFmpeg binaries (ad-hoc)
        if: env.HAS_DEV_ID == 'false'
        run: |
          codesign --force -s - src-tauri/bin/ffmpeg || true
          codesign --force -s - src-tauri/bin/ffprobe || true

      - name: Sign FFmpeg binaries (Developer ID)
        if: github.event.release.prerelease == false && env.HAS_DEV_ID == 'true'
        run: |
          for bin in ffmpeg ffprobe; do
            codesign --sign "${{ secrets.APPLE_SIGNING_IDENTITY }}" \
                     --force --options runtime \
                     --entitlements src-tauri/entitlements.plist \
                     --timestamp --verbose \
                     "src-tauri/bin/$bin"
            codesign --verify --deep --strict --verbose=2 "src-tauri/bin/$bin"
          done

      - name: Build application
        run: |
          set -euo pipefail
          : "${LICENSE_PUBLIC_KEY:?"Missing LICENSE_PUBLIC_KEY"}"

          if [ -n "${{ secrets.APPLE_ID }}" ] && [ -n "${{ secrets.APPLE_PASSWORD }}" ] && \
             [ -n "${{ secrets.APPLE_TEAM_ID }}" ] && [ -n "${{ secrets.APPLE_SIGNING_IDENTITY }}" ] && \
             [ -n "${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}" ] && [ -n "${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}" ]; then
            export APPLE_ID="${{ secrets.APPLE_ID }}"
            export APPLE_PASSWORD="${{ secrets.APPLE_PASSWORD }}"
            export APPLE_TEAM_ID="${{ secrets.APPLE_TEAM_ID }}"
            export APPLE_SIGNING_IDENTITY="${{ secrets.APPLE_SIGNING_IDENTITY }}"
            export TAURI_SIGNING_PRIVATE_KEY="${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}"
            export TAURI_SIGNING_PRIVATE_KEY_PASSWORD="${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}"
          else
            export TAURI_SKIP_SIGNING=1 TAURI_SKIP_NOTARIZE=1
          fi

          npm run tauri:build
        env:
          LICENSE_PUBLIC_KEY: ${{ secrets.LICENSE_PUBLIC_KEY }}

      - name: Stage release artifacts
        id: prepare_artifacts
        run: |
          BUNDLE_DIR="$(find src-tauri/target -type d -path '*/release/bundle' -print -quit || echo src-tauri/target/release/bundle)"
          STAGING_DIR="$BUNDLE_DIR/release-artifacts"
          mkdir -p "$STAGING_DIR"

          [ -d "$BUNDLE_DIR" ] && {
            [ -d "$BUNDLE_DIR/dmg" ] && cp "$BUNDLE_DIR/dmg"/*.dmg "$STAGING_DIR/" 2>/dev/null || true
            [ -d "$BUNDLE_DIR/macos" ] && (cd "$BUNDLE_DIR/macos" && zip -r ../release-artifacts/Honeymelon-macOS-aarch64.app.zip Honeymelon.app) || true
            compgen -G "$BUNDLE_DIR"/*.zip > /dev/null && cp "$BUNDLE_DIR"/*.zip "$STAGING_DIR/" 2>/dev/null || true
          }

          if [ -n "$(ls -A "$STAGING_DIR" 2>/dev/null)" ]; then
            ls -lh "$STAGING_DIR"
          else
            echo "Warning: No artifacts found"
          fi

      - name: Upload artifacts
        id: upload_artifacts
        env:
          UPLOAD_URL: ${{ secrets.ARTIFACT_UPLOAD_URL }}
          PLATFORM_KEY: ${{ secrets.PLATFORM_KEY }}
          PLATFORM_SECRET: ${{ secrets.PLATFORM_SECRET }}
          CF_COOKIE: ${{ secrets.CF_COOKIE }}
        run: |
          set -Eeuo pipefail
          if [ -z "${UPLOAD_URL:-}" ] || [ -z "${PLATFORM_KEY:-}" ] || [ -z "${CF_COOKIE:-}" ]; then
            echo "::warning::Missing upload secrets"
            {
              echo "artifacts_b64<<EOF"
              printf '[]' | base64
              echo "EOF"
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          upload_file() {
            local file="$1"
            local response
            response=$(curl -sS -X POST "$UPLOAD_URL" \
              -H "X-Client-Key: $PLATFORM_KEY" \
              -H "X-Client-Secret: $PLATFORM_SECRET" \
              -H "Accept: application/json" \
              -H "Cookie: $CF_COOKIE" \
              -F "platform=darwinx64" \
              -F "artifact=@$file" \
              -w "%{http_code}" \
              -o /tmp/response.json || echo "000")

            [ "$response" = "200" ] || [ "$response" = "201" ] && jq -e '.data' /tmp/response.json 2>/dev/null || echo "null"
          }

          ARTIFACTS_JSON="[]"
          while IFS= read -r -d '' file; do
            data=$(upload_file "$file")
            [ "$data" != "null" ] && ARTIFACTS_JSON=$(jq --argjson item "$data" '. + [$item]' <<< "$ARTIFACTS_JSON")
          done < <(find src-tauri/target -path '*/release/bundle/release-artifacts/*' -type f -print0)

          echo "artifacts_b64<<EOF" >> "$GITHUB_OUTPUT"
          printf '%s' "$ARTIFACTS_JSON" | base64 >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Extract metadata
        id: metadata
        run: |
          TAG="${{ github.event.release.tag_name }}"
          VERSION="${TAG#v}"
          MAJOR=$(cut -d. -f1 <<< "$VERSION")

          if ${{ github.event.release.prerelease }}; then
            CHANNEL="beta"
          elif [[ "$TAG" =~ -alpha ]]; then
            CHANNEL="alpha"
          elif [[ "$TAG" =~ -rc ]]; then
            CHANNEL="rc"
          else
            CHANNEL="stable"
          fi

          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "major=$MAJOR" >> "$GITHUB_OUTPUT"
          echo "channel=$CHANNEL" >> "$GITHUB_OUTPUT"
          echo "commit_hash=${{ github.sha }}" >> "$GITHUB_OUTPUT"

      - name: Notify webhook
        run: |
          set -euo pipefail

          ARTIFACTS_JSON=$(printf '%s' "${{ steps.upload_artifacts.outputs.artifacts_b64 }}" | base64 -d 2>/dev/null || printf '[]')
          jq . <<< "$ARTIFACTS_JSON" >/dev/null 2>&1 || ARTIFACTS_JSON='[]'

          PAYLOAD=$(jq -n \
            --arg version "${{ steps.metadata.outputs.version }}" \
            --arg tag "${{ github.event.release.tag_name }}" \
            --arg commit_hash "${{ steps.metadata.outputs.commit_hash }}" \
            --arg channel "${{ steps.metadata.outputs.channel }}" \
            --arg notes "$(jq -r '.release.body // ""' "$GITHUB_EVENT_PATH")" \
            --arg published_at "${{ github.event.release.published_at }}" \
            --argjson major "${{ steps.metadata.outputs.major }}" \
            --argjson artifacts "$ARTIFACTS_JSON" \
            '{version: $version, tag: $tag, commit_hash: $commit_hash, channel: $channel, notes: $notes, published_at: $published_at, major: $major, artifacts: $artifacts}')

          curl -X POST "${{ secrets.WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -H "X-Client-Key: ${{ secrets.PLATFORM_KEY }}" \
            -H "X-Client-Secret: ${{ secrets.PLATFORM_SECRET }}" \
            -d "$PAYLOAD"

      - name: Upload debug artifacts
        uses: actions/upload-artifact@v4
        with:
          name: honeymelon-macos-aarch64
          path: src-tauri/target/**/release/bundle/release-artifacts/*
          retention-days: 30

  create-checksums:
    needs: build-and-upload
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: honeymelon-macos-aarch64
          path: artifacts
      - run: |
          cd artifacts
          [ -z "$(find . -type f)" ] && { echo "No files"; exit 1; }
          find . -type f -print0 | sort -z | xargs -0 shasum -a 256 > SHA256SUMS.txt
          cat SHA256SUMS.txt
      - uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.event.release.tag_name }}
          files: artifacts/SHA256SUMS.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
